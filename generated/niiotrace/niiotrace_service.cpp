
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-IOTRACE Metadata
//---------------------------------------------------------------------
#include "niiotrace_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace niiotrace_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiIOTraceService::NiIOTraceService(
      NiIOTraceLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiIOTraceFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiIOTraceService::~NiIOTraceService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiIOTraceService::StartTracing(::grpc::ServerContext* context, const StartTracingRequest* request, StartTracingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32_t log_file_setting = request->log_file_setting();
      auto file_path_string = request->file_path_string().c_str();
      int32_t file_write_mode = request->file_write_mode();
      auto status = library_->StartTracing(log_file_setting, file_path_string, file_write_mode);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiIOTraceFeatureToggles::NiIOTraceFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("niiotrace", CodeReadiness::kRelease))
  {
  }
} // namespace niiotrace_grpc

