//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the IO-TRACE Metadata
//---------------------------------------------------------------------
#include "iotrace_library.h"

#if defined(_MSC_VER)
static const char* kLibraryName = "NiSpyLog.dll";
#else
static const char* kLibraryName = "liblibNiSpyLog.so";
#endif

namespace iotrace_grpc {

IOTraceLibrary::IOTraceLibrary() : shared_library_(kLibraryName)
{
  shared_library_.load();
  bool loaded = shared_library_.is_loaded();
  memset(&function_pointers_, 0, sizeof(function_pointers_));
  if (!loaded) {
    return;
  }
  function_pointers_.CloseIOTrace = reinterpret_cast<CloseIOTracePtr>(shared_library_.get_function_pointer("nispy_CloseSpy"));
  function_pointers_.GetIOTracePath = reinterpret_cast<GetIOTracePathPtr>(shared_library_.get_function_pointer("nispy_GetApplicationPath"));
  function_pointers_.LogMessage = reinterpret_cast<LogMessagePtr>(shared_library_.get_function_pointer("nispy_WriteTextEntry"));
  function_pointers_.StartTracing = reinterpret_cast<StartTracingPtr>(shared_library_.get_function_pointer("nispy_StartSpying"));
  function_pointers_.StopTracing = reinterpret_cast<StopTracingPtr>(shared_library_.get_function_pointer("nispy_StopSpying"));
}

IOTraceLibrary::~IOTraceLibrary()
{
}

::grpc::Status IOTraceLibrary::check_function_exists(std::string functionName)
{
  return shared_library_.function_exists(functionName.c_str())
    ? ::grpc::Status::OK
    : ::grpc::Status(::grpc::NOT_FOUND, "Could not find the function " + functionName);
}

eNiSpyAPICommandStatus IOTraceLibrary::CloseIOTrace()
{
  if (!function_pointers_.CloseIOTrace) {
    throw nidevice_grpc::LibraryLoadException("Could not find nispy_CloseSpy.");
  }
#if defined(_MSC_VER)
  return nispy_CloseSpy();
#else
  return function_pointers_.CloseIOTrace();
#endif
}

eNiSpyAPICommandStatus IOTraceLibrary::GetIOTracePath(char pathString[256], int32_t pathStringSize)
{
  if (!function_pointers_.GetIOTracePath) {
    throw nidevice_grpc::LibraryLoadException("Could not find nispy_GetApplicationPath.");
  }
  return function_pointers_.GetIOTracePath(pathString, pathStringSize);
}

eNiSpyAPICommandStatus IOTraceLibrary::LogMessage(const char message[])
{
  if (!function_pointers_.LogMessage) {
    throw nidevice_grpc::LibraryLoadException("Could not find nispy_WriteTextEntry.");
  }
#if defined(_MSC_VER)
  return nispy_WriteTextEntry(message);
#else
  return function_pointers_.LogMessage(message);
#endif
}

eNiSpyAPICommandStatus IOTraceLibrary::StartTracing(eNiSpyLogFileSetting logFileSetting, const char filePathString[], eNiSpyAPIFileWriteMode fileWriteMode)
{
  if (!function_pointers_.StartTracing) {
    throw nidevice_grpc::LibraryLoadException("Could not find nispy_StartSpying.");
  }
#if defined(_MSC_VER)
  return nispy_StartSpying(logFileSetting, filePathString, fileWriteMode);
#else
  return function_pointers_.StartTracing(logFileSetting, filePathString, fileWriteMode);
#endif
}

eNiSpyAPICommandStatus IOTraceLibrary::StopTracing()
{
  if (!function_pointers_.StopTracing) {
    throw nidevice_grpc::LibraryLoadException("Could not find nispy_StopSpying.");
  }
#if defined(_MSC_VER)
  return nispy_StopSpying();
#else
  return function_pointers_.StopTracing();
#endif
}

}  // namespace iotrace_grpc
