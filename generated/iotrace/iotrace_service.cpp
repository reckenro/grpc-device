
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the IO-TRACE Metadata
//---------------------------------------------------------------------
#include "iotrace_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace iotrace_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  IOTraceService::IOTraceService(
      IOTraceLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const IOTraceFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  IOTraceService::~IOTraceService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status IOTraceService::CloseIOTrace(::grpc::ServerContext* context, const CloseIOTraceRequest* request, CloseIOTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto status = library_->CloseIOTrace();
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status IOTraceService::GetIOTracePath(::grpc::ServerContext* context, const GetIOTracePathRequest* request, GetIOTracePathResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto path_string_size = 256;
      std::string path_string(256 - 1, '\0');
      auto status = library_->GetIOTracePath((char*)path_string.data(), path_string_size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_path_string(path_string);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_path_string()));
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status IOTraceService::LogMessage(::grpc::ServerContext* context, const LogMessageRequest* request, LogMessageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto message = request->message().c_str();
      auto status = library_->LogMessage(message);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status IOTraceService::StartTracing(::grpc::ServerContext* context, const StartTracingRequest* request, StartTracingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto log_file_setting = convert_from_grpc<eNiSpyLogFileSetting>(request->log_file_setting());
      auto file_path_string = request->file_path_string().c_str();
      auto file_write_mode = convert_from_grpc<eNiSpyAPIFileWriteMode>(request->file_write_mode());
      auto status = library_->StartTracing(log_file_setting, file_path_string, file_write_mode);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status IOTraceService::StopTracing(::grpc::ServerContext* context, const StopTracingRequest* request, StopTracingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto status = library_->StopTracing();
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  IOTraceFeatureToggles::IOTraceFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("iotrace", CodeReadiness::kNextRelease))
  {
  }
} // namespace iotrace_grpc

